// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.21.12
// source: message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export interface ServerBound {
  playPause?: PlayPause | undefined;
  selectPlaylist?: SelectPlaylist | undefined;
  showPotterName?: ShowPotterName | undefined;
  reportSong?: ReportSong | undefined;
}

export interface ClientBound {
  heartBeat?: HeartBeat | undefined;
  playPause?: PlayPause | undefined;
  listeners?: Listeners | undefined;
  clearPlaylists?: ClearPlaylists | undefined;
  addPlaylist?: AddPlaylist | undefined;
  selectPlaylist?: SelectPlaylist | undefined;
  ready?: Ready | undefined;
  comment?: Comment | undefined;
  data?: OpusData | undefined;
  showPotterName?: ShowPotterName | undefined;
}

export interface HeartBeat {
}

export interface PlayPause {
  isPaused: boolean;
}

export interface Listeners {
  count: number;
}

export interface Ready {
}

export interface ClearPlaylists {
}

export interface AddPlaylist {
  name: string;
  length: number;
}

export interface SelectPlaylist {
  playlist: string;
  selected: boolean;
}

export interface Comment {
  noComment: boolean;
  entries: CommentEntry[];
  songId: string;
}

export interface CommentEntry {
  key: string;
  value: string;
}

export interface OpusData {
  data: Uint8Array;
  duration: number;
  songId: string;
}

export interface OpusFrame {
  data: Uint8Array;
}

export interface ShowPotterName {
  show: boolean;
}

export interface ReportSong {
  artist: string;
  title: string;
  explanation: string;
}

function createBaseServerBound(): ServerBound {
  return { playPause: undefined, selectPlaylist: undefined, showPotterName: undefined, reportSong: undefined };
}

export const ServerBound: MessageFns<ServerBound> = {
  encode(message: ServerBound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playPause !== undefined) {
      PlayPause.encode(message.playPause, writer.uint32(10).fork()).join();
    }
    if (message.selectPlaylist !== undefined) {
      SelectPlaylist.encode(message.selectPlaylist, writer.uint32(18).fork()).join();
    }
    if (message.showPotterName !== undefined) {
      ShowPotterName.encode(message.showPotterName, writer.uint32(26).fork()).join();
    }
    if (message.reportSong !== undefined) {
      ReportSong.encode(message.reportSong, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerBound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerBound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playPause = PlayPause.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selectPlaylist = SelectPlaylist.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.showPotterName = ShowPotterName.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reportSong = ReportSong.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerBound {
    return {
      playPause: isSet(object.playPause) ? PlayPause.fromJSON(object.playPause) : undefined,
      selectPlaylist: isSet(object.selectPlaylist) ? SelectPlaylist.fromJSON(object.selectPlaylist) : undefined,
      showPotterName: isSet(object.showPotterName) ? ShowPotterName.fromJSON(object.showPotterName) : undefined,
      reportSong: isSet(object.reportSong) ? ReportSong.fromJSON(object.reportSong) : undefined,
    };
  },

  toJSON(message: ServerBound): unknown {
    const obj: any = {};
    if (message.playPause !== undefined) {
      obj.playPause = PlayPause.toJSON(message.playPause);
    }
    if (message.selectPlaylist !== undefined) {
      obj.selectPlaylist = SelectPlaylist.toJSON(message.selectPlaylist);
    }
    if (message.showPotterName !== undefined) {
      obj.showPotterName = ShowPotterName.toJSON(message.showPotterName);
    }
    if (message.reportSong !== undefined) {
      obj.reportSong = ReportSong.toJSON(message.reportSong);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerBound>, I>>(base?: I): ServerBound {
    return ServerBound.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerBound>, I>>(object: I): ServerBound {
    const message = createBaseServerBound();
    message.playPause = (object.playPause !== undefined && object.playPause !== null)
      ? PlayPause.fromPartial(object.playPause)
      : undefined;
    message.selectPlaylist = (object.selectPlaylist !== undefined && object.selectPlaylist !== null)
      ? SelectPlaylist.fromPartial(object.selectPlaylist)
      : undefined;
    message.showPotterName = (object.showPotterName !== undefined && object.showPotterName !== null)
      ? ShowPotterName.fromPartial(object.showPotterName)
      : undefined;
    message.reportSong = (object.reportSong !== undefined && object.reportSong !== null)
      ? ReportSong.fromPartial(object.reportSong)
      : undefined;
    return message;
  },
};

function createBaseClientBound(): ClientBound {
  return {
    heartBeat: undefined,
    playPause: undefined,
    listeners: undefined,
    clearPlaylists: undefined,
    addPlaylist: undefined,
    selectPlaylist: undefined,
    ready: undefined,
    comment: undefined,
    data: undefined,
    showPotterName: undefined,
  };
}

export const ClientBound: MessageFns<ClientBound> = {
  encode(message: ClientBound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heartBeat !== undefined) {
      HeartBeat.encode(message.heartBeat, writer.uint32(10).fork()).join();
    }
    if (message.playPause !== undefined) {
      PlayPause.encode(message.playPause, writer.uint32(18).fork()).join();
    }
    if (message.listeners !== undefined) {
      Listeners.encode(message.listeners, writer.uint32(26).fork()).join();
    }
    if (message.clearPlaylists !== undefined) {
      ClearPlaylists.encode(message.clearPlaylists, writer.uint32(34).fork()).join();
    }
    if (message.addPlaylist !== undefined) {
      AddPlaylist.encode(message.addPlaylist, writer.uint32(42).fork()).join();
    }
    if (message.selectPlaylist !== undefined) {
      SelectPlaylist.encode(message.selectPlaylist, writer.uint32(50).fork()).join();
    }
    if (message.ready !== undefined) {
      Ready.encode(message.ready, writer.uint32(58).fork()).join();
    }
    if (message.comment !== undefined) {
      Comment.encode(message.comment, writer.uint32(66).fork()).join();
    }
    if (message.data !== undefined) {
      OpusData.encode(message.data, writer.uint32(74).fork()).join();
    }
    if (message.showPotterName !== undefined) {
      ShowPotterName.encode(message.showPotterName, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientBound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientBound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heartBeat = HeartBeat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playPause = PlayPause.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.listeners = Listeners.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clearPlaylists = ClearPlaylists.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addPlaylist = AddPlaylist.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.selectPlaylist = SelectPlaylist.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ready = Ready.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.comment = Comment.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.data = OpusData.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.showPotterName = ShowPotterName.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientBound {
    return {
      heartBeat: isSet(object.heartBeat) ? HeartBeat.fromJSON(object.heartBeat) : undefined,
      playPause: isSet(object.playPause) ? PlayPause.fromJSON(object.playPause) : undefined,
      listeners: isSet(object.listeners) ? Listeners.fromJSON(object.listeners) : undefined,
      clearPlaylists: isSet(object.clearPlaylists) ? ClearPlaylists.fromJSON(object.clearPlaylists) : undefined,
      addPlaylist: isSet(object.addPlaylist) ? AddPlaylist.fromJSON(object.addPlaylist) : undefined,
      selectPlaylist: isSet(object.selectPlaylist) ? SelectPlaylist.fromJSON(object.selectPlaylist) : undefined,
      ready: isSet(object.ready) ? Ready.fromJSON(object.ready) : undefined,
      comment: isSet(object.comment) ? Comment.fromJSON(object.comment) : undefined,
      data: isSet(object.data) ? OpusData.fromJSON(object.data) : undefined,
      showPotterName: isSet(object.showPotterName) ? ShowPotterName.fromJSON(object.showPotterName) : undefined,
    };
  },

  toJSON(message: ClientBound): unknown {
    const obj: any = {};
    if (message.heartBeat !== undefined) {
      obj.heartBeat = HeartBeat.toJSON(message.heartBeat);
    }
    if (message.playPause !== undefined) {
      obj.playPause = PlayPause.toJSON(message.playPause);
    }
    if (message.listeners !== undefined) {
      obj.listeners = Listeners.toJSON(message.listeners);
    }
    if (message.clearPlaylists !== undefined) {
      obj.clearPlaylists = ClearPlaylists.toJSON(message.clearPlaylists);
    }
    if (message.addPlaylist !== undefined) {
      obj.addPlaylist = AddPlaylist.toJSON(message.addPlaylist);
    }
    if (message.selectPlaylist !== undefined) {
      obj.selectPlaylist = SelectPlaylist.toJSON(message.selectPlaylist);
    }
    if (message.ready !== undefined) {
      obj.ready = Ready.toJSON(message.ready);
    }
    if (message.comment !== undefined) {
      obj.comment = Comment.toJSON(message.comment);
    }
    if (message.data !== undefined) {
      obj.data = OpusData.toJSON(message.data);
    }
    if (message.showPotterName !== undefined) {
      obj.showPotterName = ShowPotterName.toJSON(message.showPotterName);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientBound>, I>>(base?: I): ClientBound {
    return ClientBound.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientBound>, I>>(object: I): ClientBound {
    const message = createBaseClientBound();
    message.heartBeat = (object.heartBeat !== undefined && object.heartBeat !== null)
      ? HeartBeat.fromPartial(object.heartBeat)
      : undefined;
    message.playPause = (object.playPause !== undefined && object.playPause !== null)
      ? PlayPause.fromPartial(object.playPause)
      : undefined;
    message.listeners = (object.listeners !== undefined && object.listeners !== null)
      ? Listeners.fromPartial(object.listeners)
      : undefined;
    message.clearPlaylists = (object.clearPlaylists !== undefined && object.clearPlaylists !== null)
      ? ClearPlaylists.fromPartial(object.clearPlaylists)
      : undefined;
    message.addPlaylist = (object.addPlaylist !== undefined && object.addPlaylist !== null)
      ? AddPlaylist.fromPartial(object.addPlaylist)
      : undefined;
    message.selectPlaylist = (object.selectPlaylist !== undefined && object.selectPlaylist !== null)
      ? SelectPlaylist.fromPartial(object.selectPlaylist)
      : undefined;
    message.ready = (object.ready !== undefined && object.ready !== null) ? Ready.fromPartial(object.ready) : undefined;
    message.comment = (object.comment !== undefined && object.comment !== null)
      ? Comment.fromPartial(object.comment)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? OpusData.fromPartial(object.data) : undefined;
    message.showPotterName = (object.showPotterName !== undefined && object.showPotterName !== null)
      ? ShowPotterName.fromPartial(object.showPotterName)
      : undefined;
    return message;
  },
};

function createBaseHeartBeat(): HeartBeat {
  return {};
}

export const HeartBeat: MessageFns<HeartBeat> = {
  encode(_: HeartBeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartBeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartBeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HeartBeat {
    return {};
  },

  toJSON(_: HeartBeat): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartBeat>, I>>(base?: I): HeartBeat {
    return HeartBeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartBeat>, I>>(_: I): HeartBeat {
    const message = createBaseHeartBeat();
    return message;
  },
};

function createBasePlayPause(): PlayPause {
  return { isPaused: false };
}

export const PlayPause: MessageFns<PlayPause> = {
  encode(message: PlayPause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isPaused !== false) {
      writer.uint32(8).bool(message.isPaused);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayPause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayPause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isPaused = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayPause {
    return { isPaused: isSet(object.isPaused) ? globalThis.Boolean(object.isPaused) : false };
  },

  toJSON(message: PlayPause): unknown {
    const obj: any = {};
    if (message.isPaused !== false) {
      obj.isPaused = message.isPaused;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayPause>, I>>(base?: I): PlayPause {
    return PlayPause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayPause>, I>>(object: I): PlayPause {
    const message = createBasePlayPause();
    message.isPaused = object.isPaused ?? false;
    return message;
  },
};

function createBaseListeners(): Listeners {
  return { count: 0 };
}

export const Listeners: MessageFns<Listeners> = {
  encode(message: Listeners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Listeners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListeners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Listeners {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: Listeners): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Listeners>, I>>(base?: I): Listeners {
    return Listeners.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Listeners>, I>>(object: I): Listeners {
    const message = createBaseListeners();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseReady(): Ready {
  return {};
}

export const Ready: MessageFns<Ready> = {
  encode(_: Ready, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ready {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReady();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Ready {
    return {};
  },

  toJSON(_: Ready): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Ready>, I>>(base?: I): Ready {
    return Ready.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ready>, I>>(_: I): Ready {
    const message = createBaseReady();
    return message;
  },
};

function createBaseClearPlaylists(): ClearPlaylists {
  return {};
}

export const ClearPlaylists: MessageFns<ClearPlaylists> = {
  encode(_: ClearPlaylists, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearPlaylists {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearPlaylists();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearPlaylists {
    return {};
  },

  toJSON(_: ClearPlaylists): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearPlaylists>, I>>(base?: I): ClearPlaylists {
    return ClearPlaylists.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearPlaylists>, I>>(_: I): ClearPlaylists {
    const message = createBaseClearPlaylists();
    return message;
  },
};

function createBaseAddPlaylist(): AddPlaylist {
  return { name: "", length: 0 };
}

export const AddPlaylist: MessageFns<AddPlaylist> = {
  encode(message: AddPlaylist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.length !== 0) {
      writer.uint32(16).uint64(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPlaylist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPlaylist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddPlaylist {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: AddPlaylist): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddPlaylist>, I>>(base?: I): AddPlaylist {
    return AddPlaylist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddPlaylist>, I>>(object: I): AddPlaylist {
    const message = createBaseAddPlaylist();
    message.name = object.name ?? "";
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseSelectPlaylist(): SelectPlaylist {
  return { playlist: "", selected: false };
}

export const SelectPlaylist: MessageFns<SelectPlaylist> = {
  encode(message: SelectPlaylist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playlist !== "") {
      writer.uint32(10).string(message.playlist);
    }
    if (message.selected !== false) {
      writer.uint32(16).bool(message.selected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectPlaylist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectPlaylist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playlist = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.selected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectPlaylist {
    return {
      playlist: isSet(object.playlist) ? globalThis.String(object.playlist) : "",
      selected: isSet(object.selected) ? globalThis.Boolean(object.selected) : false,
    };
  },

  toJSON(message: SelectPlaylist): unknown {
    const obj: any = {};
    if (message.playlist !== "") {
      obj.playlist = message.playlist;
    }
    if (message.selected !== false) {
      obj.selected = message.selected;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectPlaylist>, I>>(base?: I): SelectPlaylist {
    return SelectPlaylist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectPlaylist>, I>>(object: I): SelectPlaylist {
    const message = createBaseSelectPlaylist();
    message.playlist = object.playlist ?? "";
    message.selected = object.selected ?? false;
    return message;
  },
};

function createBaseComment(): Comment {
  return { noComment: false, entries: [], songId: "" };
}

export const Comment: MessageFns<Comment> = {
  encode(message: Comment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.noComment !== false) {
      writer.uint32(8).bool(message.noComment);
    }
    for (const v of message.entries) {
      CommentEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.songId !== "") {
      writer.uint32(26).string(message.songId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.noComment = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entries.push(CommentEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.songId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comment {
    return {
      noComment: isSet(object.noComment) ? globalThis.Boolean(object.noComment) : false,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => CommentEntry.fromJSON(e))
        : [],
      songId: isSet(object.songId) ? globalThis.String(object.songId) : "",
    };
  },

  toJSON(message: Comment): unknown {
    const obj: any = {};
    if (message.noComment !== false) {
      obj.noComment = message.noComment;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => CommentEntry.toJSON(e));
    }
    if (message.songId !== "") {
      obj.songId = message.songId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Comment>, I>>(base?: I): Comment {
    return Comment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Comment>, I>>(object: I): Comment {
    const message = createBaseComment();
    message.noComment = object.noComment ?? false;
    message.entries = object.entries?.map((e) => CommentEntry.fromPartial(e)) || [];
    message.songId = object.songId ?? "";
    return message;
  },
};

function createBaseCommentEntry(): CommentEntry {
  return { key: "", value: "" };
}

export const CommentEntry: MessageFns<CommentEntry> = {
  encode(message: CommentEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommentEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommentEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommentEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CommentEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommentEntry>, I>>(base?: I): CommentEntry {
    return CommentEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommentEntry>, I>>(object: I): CommentEntry {
    const message = createBaseCommentEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOpusData(): OpusData {
  return { data: new Uint8Array(0), duration: 0, songId: "" };
}

export const OpusData: MessageFns<OpusData> = {
  encode(message: OpusData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.duration !== 0) {
      writer.uint32(16).uint32(message.duration);
    }
    if (message.songId !== "") {
      writer.uint32(26).string(message.songId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpusData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpusData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.songId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpusData {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      songId: isSet(object.songId) ? globalThis.String(object.songId) : "",
    };
  },

  toJSON(message: OpusData): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.songId !== "") {
      obj.songId = message.songId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpusData>, I>>(base?: I): OpusData {
    return OpusData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpusData>, I>>(object: I): OpusData {
    const message = createBaseOpusData();
    message.data = object.data ?? new Uint8Array(0);
    message.duration = object.duration ?? 0;
    message.songId = object.songId ?? "";
    return message;
  },
};

function createBaseOpusFrame(): OpusFrame {
  return { data: new Uint8Array(0) };
}

export const OpusFrame: MessageFns<OpusFrame> = {
  encode(message: OpusFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpusFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpusFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpusFrame {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: OpusFrame): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpusFrame>, I>>(base?: I): OpusFrame {
    return OpusFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpusFrame>, I>>(object: I): OpusFrame {
    const message = createBaseOpusFrame();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseShowPotterName(): ShowPotterName {
  return { show: false };
}

export const ShowPotterName: MessageFns<ShowPotterName> = {
  encode(message: ShowPotterName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.show !== false) {
      writer.uint32(8).bool(message.show);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowPotterName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowPotterName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.show = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowPotterName {
    return { show: isSet(object.show) ? globalThis.Boolean(object.show) : false };
  },

  toJSON(message: ShowPotterName): unknown {
    const obj: any = {};
    if (message.show !== false) {
      obj.show = message.show;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShowPotterName>, I>>(base?: I): ShowPotterName {
    return ShowPotterName.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShowPotterName>, I>>(object: I): ShowPotterName {
    const message = createBaseShowPotterName();
    message.show = object.show ?? false;
    return message;
  },
};

function createBaseReportSong(): ReportSong {
  return { artist: "", title: "", explanation: "" };
}

export const ReportSong: MessageFns<ReportSong> = {
  encode(message: ReportSong, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artist !== "") {
      writer.uint32(10).string(message.artist);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.explanation !== "") {
      writer.uint32(26).string(message.explanation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSong {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artist = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSong {
    return {
      artist: isSet(object.artist) ? globalThis.String(object.artist) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
    };
  },

  toJSON(message: ReportSong): unknown {
    const obj: any = {};
    if (message.artist !== "") {
      obj.artist = message.artist;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportSong>, I>>(base?: I): ReportSong {
    return ReportSong.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportSong>, I>>(object: I): ReportSong {
    const message = createBaseReportSong();
    message.artist = object.artist ?? "";
    message.title = object.title ?? "";
    message.explanation = object.explanation ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
