// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `message.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct ServerBound {
    // message oneof groups
    pub field_type: ::std::option::Option<ServerBound_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerBound {
    fn default() -> &'a ServerBound {
        <ServerBound as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ServerBound_oneof_type {
    play_pause(PlayPause),
    select_playlist(SelectPlaylist),
}

impl ServerBound {
    pub fn new() -> ServerBound {
        ::std::default::Default::default()
    }

    // .PlayPause play_pause = 1;


    pub fn get_play_pause(&self) -> &PlayPause {
        match self.field_type {
            ::std::option::Option::Some(ServerBound_oneof_type::play_pause(ref v)) => v,
            _ => <PlayPause as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_play_pause(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_play_pause(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ServerBound_oneof_type::play_pause(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_play_pause(&mut self, v: PlayPause) {
        self.field_type = ::std::option::Option::Some(ServerBound_oneof_type::play_pause(v))
    }

    // Mutable pointer to the field.
    pub fn mut_play_pause(&mut self) -> &mut PlayPause {
        if let ::std::option::Option::Some(ServerBound_oneof_type::play_pause(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ServerBound_oneof_type::play_pause(PlayPause::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ServerBound_oneof_type::play_pause(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_play_pause(&mut self) -> PlayPause {
        if self.has_play_pause() {
            match self.field_type.take() {
                ::std::option::Option::Some(ServerBound_oneof_type::play_pause(v)) => v,
                _ => panic!(),
            }
        } else {
            PlayPause::new()
        }
    }

    // .SelectPlaylist select_playlist = 2;


    pub fn get_select_playlist(&self) -> &SelectPlaylist {
        match self.field_type {
            ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(ref v)) => v,
            _ => <SelectPlaylist as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select_playlist(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_select_playlist(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_playlist(&mut self, v: SelectPlaylist) {
        self.field_type = ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_playlist(&mut self) -> &mut SelectPlaylist {
        if let ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(SelectPlaylist::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_playlist(&mut self) -> SelectPlaylist {
        if self.has_select_playlist() {
            match self.field_type.take() {
                ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(v)) => v,
                _ => panic!(),
            }
        } else {
            SelectPlaylist::new()
        }
    }
}

impl ::protobuf::Message for ServerBound {
    fn is_initialized(&self) -> bool {
        if let Some(ServerBound_oneof_type::play_pause(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ServerBound_oneof_type::select_playlist(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ServerBound_oneof_type::play_pause(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ServerBound_oneof_type::select_playlist(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &ServerBound_oneof_type::play_pause(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ServerBound_oneof_type::select_playlist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &ServerBound_oneof_type::play_pause(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ServerBound_oneof_type::select_playlist(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerBound {
        ServerBound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlayPause>(
                "play_pause",
                ServerBound::has_play_pause,
                ServerBound::get_play_pause,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SelectPlaylist>(
                "select_playlist",
                ServerBound::has_select_playlist,
                ServerBound::get_select_playlist,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerBound>(
                "ServerBound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerBound {
        static instance: ::protobuf::rt::LazyV2<ServerBound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerBound::new)
    }
}

impl ::protobuf::Clear for ServerBound {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerBound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerBound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientBound {
    // message oneof groups
    pub field_type: ::std::option::Option<ClientBound_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientBound {
    fn default() -> &'a ClientBound {
        <ClientBound as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ClientBound_oneof_type {
    heart_beat(HeartBeat),
    play_pause(PlayPause),
    listeners(Listeners),
    clear_playlists(ClearPlaylists),
    add_playlist(AddPlaylist),
    select_playlist(SelectPlaylist),
    ready(Ready),
    comment(Comment),
    data(OpusData),
}

impl ClientBound {
    pub fn new() -> ClientBound {
        ::std::default::Default::default()
    }

    // .HeartBeat heart_beat = 1;


    pub fn get_heart_beat(&self) -> &HeartBeat {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(ref v)) => v,
            _ => <HeartBeat as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_heart_beat(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_heart_beat(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_heart_beat(&mut self, v: HeartBeat) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_heart_beat(&mut self) -> &mut HeartBeat {
        if let ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(HeartBeat::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_heart_beat(&mut self) -> HeartBeat {
        if self.has_heart_beat() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(v)) => v,
                _ => panic!(),
            }
        } else {
            HeartBeat::new()
        }
    }

    // .PlayPause play_pause = 2;


    pub fn get_play_pause(&self) -> &PlayPause {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::play_pause(ref v)) => v,
            _ => <PlayPause as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_play_pause(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_play_pause(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::play_pause(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_play_pause(&mut self, v: PlayPause) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::play_pause(v))
    }

    // Mutable pointer to the field.
    pub fn mut_play_pause(&mut self) -> &mut PlayPause {
        if let ::std::option::Option::Some(ClientBound_oneof_type::play_pause(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::play_pause(PlayPause::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::play_pause(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_play_pause(&mut self) -> PlayPause {
        if self.has_play_pause() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::play_pause(v)) => v,
                _ => panic!(),
            }
        } else {
            PlayPause::new()
        }
    }

    // .Listeners listeners = 3;


    pub fn get_listeners(&self) -> &Listeners {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::listeners(ref v)) => v,
            _ => <Listeners as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_listeners(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_listeners(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::listeners(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_listeners(&mut self, v: Listeners) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::listeners(v))
    }

    // Mutable pointer to the field.
    pub fn mut_listeners(&mut self) -> &mut Listeners {
        if let ::std::option::Option::Some(ClientBound_oneof_type::listeners(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::listeners(Listeners::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::listeners(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_listeners(&mut self) -> Listeners {
        if self.has_listeners() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::listeners(v)) => v,
                _ => panic!(),
            }
        } else {
            Listeners::new()
        }
    }

    // .ClearPlaylists clear_playlists = 4;


    pub fn get_clear_playlists(&self) -> &ClearPlaylists {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(ref v)) => v,
            _ => <ClearPlaylists as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_clear_playlists(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_clear_playlists(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clear_playlists(&mut self, v: ClearPlaylists) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clear_playlists(&mut self) -> &mut ClearPlaylists {
        if let ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(ClearPlaylists::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clear_playlists(&mut self) -> ClearPlaylists {
        if self.has_clear_playlists() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(v)) => v,
                _ => panic!(),
            }
        } else {
            ClearPlaylists::new()
        }
    }

    // .AddPlaylist add_playlist = 5;


    pub fn get_add_playlist(&self) -> &AddPlaylist {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(ref v)) => v,
            _ => <AddPlaylist as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_add_playlist(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_add_playlist(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_playlist(&mut self, v: AddPlaylist) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_playlist(&mut self) -> &mut AddPlaylist {
        if let ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(AddPlaylist::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_playlist(&mut self) -> AddPlaylist {
        if self.has_add_playlist() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(v)) => v,
                _ => panic!(),
            }
        } else {
            AddPlaylist::new()
        }
    }

    // .SelectPlaylist select_playlist = 6;


    pub fn get_select_playlist(&self) -> &SelectPlaylist {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(ref v)) => v,
            _ => <SelectPlaylist as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select_playlist(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_select_playlist(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_playlist(&mut self, v: SelectPlaylist) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_playlist(&mut self) -> &mut SelectPlaylist {
        if let ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(SelectPlaylist::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_playlist(&mut self) -> SelectPlaylist {
        if self.has_select_playlist() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(v)) => v,
                _ => panic!(),
            }
        } else {
            SelectPlaylist::new()
        }
    }

    // .Ready ready = 7;


    pub fn get_ready(&self) -> &Ready {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::ready(ref v)) => v,
            _ => <Ready as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ready(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_ready(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::ready(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: Ready) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::ready(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ready(&mut self) -> &mut Ready {
        if let ::std::option::Option::Some(ClientBound_oneof_type::ready(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::ready(Ready::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::ready(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ready(&mut self) -> Ready {
        if self.has_ready() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::ready(v)) => v,
                _ => panic!(),
            }
        } else {
            Ready::new()
        }
    }

    // .Comment comment = 8;


    pub fn get_comment(&self) -> &Comment {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::comment(ref v)) => v,
            _ => <Comment as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_comment(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::comment(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: Comment) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::comment(v))
    }

    // Mutable pointer to the field.
    pub fn mut_comment(&mut self) -> &mut Comment {
        if let ::std::option::Option::Some(ClientBound_oneof_type::comment(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::comment(Comment::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::comment(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_comment(&mut self) -> Comment {
        if self.has_comment() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::comment(v)) => v,
                _ => panic!(),
            }
        } else {
            Comment::new()
        }
    }

    // .OpusData data = 9;


    pub fn get_data(&self) -> &OpusData {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::data(ref v)) => v,
            _ => <OpusData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_data(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: OpusData) {
        self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut OpusData {
        if let ::std::option::Option::Some(ClientBound_oneof_type::data(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::data(OpusData::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ClientBound_oneof_type::data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> OpusData {
        if self.has_data() {
            match self.field_type.take() {
                ::std::option::Option::Some(ClientBound_oneof_type::data(v)) => v,
                _ => panic!(),
            }
        } else {
            OpusData::new()
        }
    }
}

impl ::protobuf::Message for ClientBound {
    fn is_initialized(&self) -> bool {
        if let Some(ClientBound_oneof_type::heart_beat(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::play_pause(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::listeners(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::clear_playlists(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::add_playlist(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::select_playlist(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::ready(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::comment(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientBound_oneof_type::data(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::heart_beat(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::play_pause(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::listeners(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::clear_playlists(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::add_playlist(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::select_playlist(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::ready(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::comment(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ClientBound_oneof_type::data(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &ClientBound_oneof_type::heart_beat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::play_pause(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::listeners(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::clear_playlists(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::add_playlist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::select_playlist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::ready(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::comment(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientBound_oneof_type::data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &ClientBound_oneof_type::heart_beat(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::play_pause(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::listeners(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::clear_playlists(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::add_playlist(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::select_playlist(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::ready(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::comment(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientBound_oneof_type::data(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientBound {
        ClientBound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HeartBeat>(
                "heart_beat",
                ClientBound::has_heart_beat,
                ClientBound::get_heart_beat,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlayPause>(
                "play_pause",
                ClientBound::has_play_pause,
                ClientBound::get_play_pause,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Listeners>(
                "listeners",
                ClientBound::has_listeners,
                ClientBound::get_listeners,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ClearPlaylists>(
                "clear_playlists",
                ClientBound::has_clear_playlists,
                ClientBound::get_clear_playlists,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AddPlaylist>(
                "add_playlist",
                ClientBound::has_add_playlist,
                ClientBound::get_add_playlist,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SelectPlaylist>(
                "select_playlist",
                ClientBound::has_select_playlist,
                ClientBound::get_select_playlist,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ready>(
                "ready",
                ClientBound::has_ready,
                ClientBound::get_ready,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Comment>(
                "comment",
                ClientBound::has_comment,
                ClientBound::get_comment,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OpusData>(
                "data",
                ClientBound::has_data,
                ClientBound::get_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientBound>(
                "ClientBound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientBound {
        static instance: ::protobuf::rt::LazyV2<ClientBound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientBound::new)
    }
}

impl ::protobuf::Clear for ClientBound {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientBound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientBound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartBeat {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartBeat {
    fn default() -> &'a HeartBeat {
        <HeartBeat as ::protobuf::Message>::default_instance()
    }
}

impl HeartBeat {
    pub fn new() -> HeartBeat {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HeartBeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartBeat {
        HeartBeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeartBeat>(
                "HeartBeat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeartBeat {
        static instance: ::protobuf::rt::LazyV2<HeartBeat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeartBeat::new)
    }
}

impl ::protobuf::Clear for HeartBeat {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartBeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartBeat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayPause {
    // message fields
    pub is_paused: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayPause {
    fn default() -> &'a PlayPause {
        <PlayPause as ::protobuf::Message>::default_instance()
    }
}

impl PlayPause {
    pub fn new() -> PlayPause {
        ::std::default::Default::default()
    }

    // bool is_paused = 1;


    pub fn get_is_paused(&self) -> bool {
        self.is_paused
    }
    pub fn clear_is_paused(&mut self) {
        self.is_paused = false;
    }

    // Param is passed by value, moved
    pub fn set_is_paused(&mut self, v: bool) {
        self.is_paused = v;
    }
}

impl ::protobuf::Message for PlayPause {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_paused = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_paused != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_paused != false {
            os.write_bool(1, self.is_paused)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayPause {
        PlayPause::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_paused",
                |m: &PlayPause| { &m.is_paused },
                |m: &mut PlayPause| { &mut m.is_paused },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayPause>(
                "PlayPause",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayPause {
        static instance: ::protobuf::rt::LazyV2<PlayPause> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayPause::new)
    }
}

impl ::protobuf::Clear for PlayPause {
    fn clear(&mut self) {
        self.is_paused = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayPause {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Listeners {
    // message fields
    pub count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Listeners {
    fn default() -> &'a Listeners {
        <Listeners as ::protobuf::Message>::default_instance()
    }
}

impl Listeners {
    pub fn new() -> Listeners {
        ::std::default::Default::default()
    }

    // uint64 count = 1;


    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }
}

impl ::protobuf::Message for Listeners {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint64(1, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Listeners {
        Listeners::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "count",
                |m: &Listeners| { &m.count },
                |m: &mut Listeners| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Listeners>(
                "Listeners",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Listeners {
        static instance: ::protobuf::rt::LazyV2<Listeners> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Listeners::new)
    }
}

impl ::protobuf::Clear for Listeners {
    fn clear(&mut self) {
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Listeners {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Listeners {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ready {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ready {
    fn default() -> &'a Ready {
        <Ready as ::protobuf::Message>::default_instance()
    }
}

impl Ready {
    pub fn new() -> Ready {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Ready {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ready {
        Ready::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ready>(
                "Ready",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ready {
        static instance: ::protobuf::rt::LazyV2<Ready> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ready::new)
    }
}

impl ::protobuf::Clear for Ready {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ready {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ready {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearPlaylists {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearPlaylists {
    fn default() -> &'a ClearPlaylists {
        <ClearPlaylists as ::protobuf::Message>::default_instance()
    }
}

impl ClearPlaylists {
    pub fn new() -> ClearPlaylists {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClearPlaylists {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearPlaylists {
        ClearPlaylists::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClearPlaylists>(
                "ClearPlaylists",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClearPlaylists {
        static instance: ::protobuf::rt::LazyV2<ClearPlaylists> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClearPlaylists::new)
    }
}

impl ::protobuf::Clear for ClearPlaylists {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearPlaylists {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearPlaylists {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPlaylist {
    // message fields
    pub name: ::std::string::String,
    pub length: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPlaylist {
    fn default() -> &'a AddPlaylist {
        <AddPlaylist as ::protobuf::Message>::default_instance()
    }
}

impl AddPlaylist {
    pub fn new() -> AddPlaylist {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }
}

impl ::protobuf::Message for AddPlaylist {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(2, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.length != 0 {
            os.write_uint64(2, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPlaylist {
        AddPlaylist::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AddPlaylist| { &m.name },
                |m: &mut AddPlaylist| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &AddPlaylist| { &m.length },
                |m: &mut AddPlaylist| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddPlaylist>(
                "AddPlaylist",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddPlaylist {
        static instance: ::protobuf::rt::LazyV2<AddPlaylist> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddPlaylist::new)
    }
}

impl ::protobuf::Clear for AddPlaylist {
    fn clear(&mut self) {
        self.name.clear();
        self.length = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPlaylist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPlaylist {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelectPlaylist {
    // message fields
    pub index: u64,
    pub selected: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectPlaylist {
    fn default() -> &'a SelectPlaylist {
        <SelectPlaylist as ::protobuf::Message>::default_instance()
    }
}

impl SelectPlaylist {
    pub fn new() -> SelectPlaylist {
        ::std::default::Default::default()
    }

    // uint64 index = 1;


    pub fn get_index(&self) -> u64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u64) {
        self.index = v;
    }

    // bool selected = 2;


    pub fn get_selected(&self) -> bool {
        self.selected
    }
    pub fn clear_selected(&mut self) {
        self.selected = false;
    }

    // Param is passed by value, moved
    pub fn set_selected(&mut self, v: bool) {
        self.selected = v;
    }
}

impl ::protobuf::Message for SelectPlaylist {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.selected != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_uint64(1, self.index)?;
        }
        if self.selected != false {
            os.write_bool(2, self.selected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectPlaylist {
        SelectPlaylist::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "index",
                |m: &SelectPlaylist| { &m.index },
                |m: &mut SelectPlaylist| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selected",
                |m: &SelectPlaylist| { &m.selected },
                |m: &mut SelectPlaylist| { &mut m.selected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectPlaylist>(
                "SelectPlaylist",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectPlaylist {
        static instance: ::protobuf::rt::LazyV2<SelectPlaylist> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectPlaylist::new)
    }
}

impl ::protobuf::Clear for SelectPlaylist {
    fn clear(&mut self) {
        self.index = 0;
        self.selected = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectPlaylist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectPlaylist {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Comment {
    // message fields
    pub noComment: bool,
    pub entries: ::protobuf::RepeatedField<CommentEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Comment {
    fn default() -> &'a Comment {
        <Comment as ::protobuf::Message>::default_instance()
    }
}

impl Comment {
    pub fn new() -> Comment {
        ::std::default::Default::default()
    }

    // bool noComment = 1;


    pub fn get_noComment(&self) -> bool {
        self.noComment
    }
    pub fn clear_noComment(&mut self) {
        self.noComment = false;
    }

    // Param is passed by value, moved
    pub fn set_noComment(&mut self, v: bool) {
        self.noComment = v;
    }

    // repeated .CommentEntry entries = 2;


    pub fn get_entries(&self) -> &[CommentEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CommentEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CommentEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CommentEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Comment {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noComment = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.noComment != false {
            my_size += 2;
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.noComment != false {
            os.write_bool(1, self.noComment)?;
        }
        for v in &self.entries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Comment {
        Comment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noComment",
                |m: &Comment| { &m.noComment },
                |m: &mut Comment| { &mut m.noComment },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentEntry>>(
                "entries",
                |m: &Comment| { &m.entries },
                |m: &mut Comment| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Comment>(
                "Comment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Comment {
        static instance: ::protobuf::rt::LazyV2<Comment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Comment::new)
    }
}

impl ::protobuf::Clear for Comment {
    fn clear(&mut self) {
        self.noComment = false;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Comment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Comment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommentEntry {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommentEntry {
    fn default() -> &'a CommentEntry {
        <CommentEntry as ::protobuf::Message>::default_instance()
    }
}

impl CommentEntry {
    pub fn new() -> CommentEntry {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommentEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommentEntry {
        CommentEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &CommentEntry| { &m.key },
                |m: &mut CommentEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CommentEntry| { &m.value },
                |m: &mut CommentEntry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommentEntry>(
                "CommentEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommentEntry {
        static instance: ::protobuf::rt::LazyV2<CommentEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommentEntry::new)
    }
}

impl ::protobuf::Clear for CommentEntry {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommentEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommentEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpusData {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub duration: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpusData {
    fn default() -> &'a OpusData {
        <OpusData as ::protobuf::Message>::default_instance()
    }
}

impl OpusData {
    pub fn new() -> OpusData {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // uint32 duration = 2;


    pub fn get_duration(&self) -> u32 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = v;
    }
}

impl ::protobuf::Message for OpusData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(2, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.duration != 0 {
            os.write_uint32(2, self.duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpusData {
        OpusData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &OpusData| { &m.data },
                |m: &mut OpusData| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duration",
                |m: &OpusData| { &m.duration },
                |m: &mut OpusData| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpusData>(
                "OpusData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpusData {
        static instance: ::protobuf::rt::LazyV2<OpusData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpusData::new)
    }
}

impl ::protobuf::Clear for OpusData {
    fn clear(&mut self) {
        self.data.clear();
        self.duration = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpusData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpusData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpusFrame {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpusFrame {
    fn default() -> &'a OpusFrame {
        <OpusFrame as ::protobuf::Message>::default_instance()
    }
}

impl OpusFrame {
    pub fn new() -> OpusFrame {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OpusFrame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpusFrame {
        OpusFrame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &OpusFrame| { &m.data },
                |m: &mut OpusFrame| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpusFrame>(
                "OpusFrame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpusFrame {
        static instance: ::protobuf::rt::LazyV2<OpusFrame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpusFrame::new)
    }
}

impl ::protobuf::Clear for OpusFrame {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpusFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpusFrame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\"~\n\x0bServerBound\x12+\n\nplay_pause\x18\x01\x20\x01\
    (\x0b2\n.PlayPauseH\0R\tplayPause\x12:\n\x0fselect_playlist\x18\x02\x20\
    \x01(\x0b2\x0f.SelectPlaylistH\0R\x0eselectPlaylistB\x06\n\x04type\"\xad\
    \x03\n\x0bClientBound\x12+\n\nheart_beat\x18\x01\x20\x01(\x0b2\n.HeartBe\
    atH\0R\theartBeat\x12+\n\nplay_pause\x18\x02\x20\x01(\x0b2\n.PlayPauseH\
    \0R\tplayPause\x12*\n\tlisteners\x18\x03\x20\x01(\x0b2\n.ListenersH\0R\t\
    listeners\x12:\n\x0fclear_playlists\x18\x04\x20\x01(\x0b2\x0f.ClearPlayl\
    istsH\0R\x0eclearPlaylists\x121\n\x0cadd_playlist\x18\x05\x20\x01(\x0b2\
    \x0c.AddPlaylistH\0R\x0baddPlaylist\x12:\n\x0fselect_playlist\x18\x06\
    \x20\x01(\x0b2\x0f.SelectPlaylistH\0R\x0eselectPlaylist\x12\x1e\n\x05rea\
    dy\x18\x07\x20\x01(\x0b2\x06.ReadyH\0R\x05ready\x12$\n\x07comment\x18\
    \x08\x20\x01(\x0b2\x08.CommentH\0R\x07comment\x12\x1f\n\x04data\x18\t\
    \x20\x01(\x0b2\t.OpusDataH\0R\x04dataB\x06\n\x04type\"\x0b\n\tHeartBeat\
    \"(\n\tPlayPause\x12\x1b\n\tis_paused\x18\x01\x20\x01(\x08R\x08isPaused\
    \"!\n\tListeners\x12\x14\n\x05count\x18\x01\x20\x01(\x04R\x05count\"\x07\
    \n\x05Ready\"\x10\n\x0eClearPlaylists\"9\n\x0bAddPlaylist\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06length\x18\x02\x20\x01(\x04\
    R\x06length\"B\n\x0eSelectPlaylist\x12\x14\n\x05index\x18\x01\x20\x01(\
    \x04R\x05index\x12\x1a\n\x08selected\x18\x02\x20\x01(\x08R\x08selected\"\
    P\n\x07Comment\x12\x1c\n\tnoComment\x18\x01\x20\x01(\x08R\tnoComment\x12\
    '\n\x07entries\x18\x02\x20\x03(\x0b2\r.CommentEntryR\x07entries\"6\n\x0c\
    CommentEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\tR\x05value\":\n\x08OpusData\x12\x12\n\x04data\x18\
    \x01\x20\x01(\x0cR\x04data\x12\x1a\n\x08duration\x18\x02\x20\x01(\rR\x08\
    duration\"\x1f\n\tOpusFrame\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04d\
    ataJ\xb7\r\n\x06\x12\x04\0\0B\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\n\n\
    \x02\x04\0\x12\x04\x02\0\x07\x01\n\n\n\x03\x04\0\x01\x12\x03\x02\x08\x13\
    \n\x0c\n\x04\x04\0\x08\0\x12\x04\x03\x02\x06\x03\n\x0c\n\x05\x04\0\x08\0\
    \x01\x12\x03\x03\x08\x0c\n\x0b\n\x04\x04\0\x02\0\x12\x03\x04\x04\x1d\n\
    \x0c\n\x05\x04\0\x02\0\x06\x12\x03\x04\x04\r\n\x0c\n\x05\x04\0\x02\0\x01\
    \x12\x03\x04\x0e\x18\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x04\x1b\x1c\n\
    \x0b\n\x04\x04\0\x02\x01\x12\x03\x05\x04'\n\x0c\n\x05\x04\0\x02\x01\x06\
    \x12\x03\x05\x04\x12\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x05\x13\"\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x05%&\n\n\n\x02\x04\x01\x12\x04\t\0\
    \x15\x01\n\n\n\x03\x04\x01\x01\x12\x03\t\x08\x13\n\x0c\n\x04\x04\x01\x08\
    \0\x12\x04\n\x02\x14\x03\n\x0c\n\x05\x04\x01\x08\0\x01\x12\x03\n\x08\x0c\
    \n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0b\x04\x1d\n\x0c\n\x05\x04\x01\x02\0\
    \x06\x12\x03\x0b\x04\r\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x0b\x0e\x18\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0b\x1b\x1c\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03\x0c\x04\x1d\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x0c\
    \x04\r\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0c\x0e\x18\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03\x0c\x1b\x1c\n\x0b\n\x04\x04\x01\x02\x02\x12\
    \x03\r\x04\x1c\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03\r\x04\r\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03\r\x0e\x17\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03\r\x1a\x1b\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x0e\x04'\n\
    \x0c\n\x05\x04\x01\x02\x03\x06\x12\x03\x0e\x04\x12\n\x0c\n\x05\x04\x01\
    \x02\x03\x01\x12\x03\x0e\x13\"\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\
    \x0e%&\n\x0b\n\x04\x04\x01\x02\x04\x12\x03\x0f\x04!\n\x0c\n\x05\x04\x01\
    \x02\x04\x06\x12\x03\x0f\x04\x0f\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03\
    \x0f\x10\x1c\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\x0f\x1f\x20\n\x0b\n\
    \x04\x04\x01\x02\x05\x12\x03\x10\x04'\n\x0c\n\x05\x04\x01\x02\x05\x06\
    \x12\x03\x10\x04\x12\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x10\x13\"\n\
    \x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\x10%&\n\x0b\n\x04\x04\x01\x02\x06\
    \x12\x03\x11\x04\x14\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03\x11\x04\t\n\
    \x0c\n\x05\x04\x01\x02\x06\x01\x12\x03\x11\n\x0f\n\x0c\n\x05\x04\x01\x02\
    \x06\x03\x12\x03\x11\x12\x13\n\x0b\n\x04\x04\x01\x02\x07\x12\x03\x12\x04\
    \x18\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03\x12\x04\x0b\n\x0c\n\x05\x04\
    \x01\x02\x07\x01\x12\x03\x12\x0c\x13\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\
    \x03\x12\x16\x17\n\x0b\n\x04\x04\x01\x02\x08\x12\x03\x13\x04\x16\n\x0c\n\
    \x05\x04\x01\x02\x08\x06\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\x01\x02\x08\
    \x01\x12\x03\x13\r\x11\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03\x13\x14\
    \x15\n\n\n\x02\x04\x02\x12\x04\x17\0\x18\x01\n\n\n\x03\x04\x02\x01\x12\
    \x03\x17\x08\x11\n\n\n\x02\x04\x03\x12\x04\x1a\0\x1c\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03\x1a\x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1b\x02\
    \x15\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x1b\x02\x06\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03\x1b\x07\x10\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\
    \x1b\x13\x14\n\n\n\x02\x04\x04\x12\x04\x1e\0\x20\x01\n\n\n\x03\x04\x04\
    \x01\x12\x03\x1e\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03\x1f\x02\x13\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03\x1f\t\x0e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\x1f\x11\
    \x12\n\n\n\x02\x04\x05\x12\x04\"\0#\x01\n\n\n\x03\x04\x05\x01\x12\x03\"\
    \x08\r\n\t\n\x02\x04\x06\x12\x03%\0\x19\n\n\n\x03\x04\x06\x01\x12\x03%\
    \x08\x16\n\n\n\x02\x04\x07\x12\x04'\0*\x01\n\n\n\x03\x04\x07\x01\x12\x03\
    '\x08\x13\n\x0b\n\x04\x04\x07\x02\0\x12\x03(\x02\x12\n\x0c\n\x05\x04\x07\
    \x02\0\x05\x12\x03(\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03(\t\r\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03(\x10\x11\n\x0b\n\x04\x04\x07\x02\
    \x01\x12\x03)\x02\x14\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03)\x02\x08\n\
    \x0c\n\x05\x04\x07\x02\x01\x01\x12\x03)\t\x0f\n\x0c\n\x05\x04\x07\x02\
    \x01\x03\x12\x03)\x12\x13\n\n\n\x02\x04\x08\x12\x04,\0/\x01\n\n\n\x03\
    \x04\x08\x01\x12\x03,\x08\x16\n\x0b\n\x04\x04\x08\x02\0\x12\x03-\x02\x13\
    \n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\x08\x02\
    \0\x01\x12\x03-\t\x0e\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03-\x11\x12\n\
    \x0b\n\x04\x04\x08\x02\x01\x12\x03.\x02\x14\n\x0c\n\x05\x04\x08\x02\x01\
    \x05\x12\x03.\x02\x06\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03.\x07\x0f\n\
    \x0c\n\x05\x04\x08\x02\x01\x03\x12\x03.\x12\x13\n\n\n\x02\x04\t\x12\x041\
    \04\x01\n\n\n\x03\x04\t\x01\x12\x031\x08\x0f\n\x0b\n\x04\x04\t\x02\0\x12\
    \x032\x02\x15\n\x0c\n\x05\x04\t\x02\0\x05\x12\x032\x02\x06\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x032\x07\x10\n\x0c\n\x05\x04\t\x02\0\x03\x12\x032\
    \x13\x14\n\x0b\n\x04\x04\t\x02\x01\x12\x033\x02$\n\x0c\n\x05\x04\t\x02\
    \x01\x04\x12\x033\x02\n\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x033\x0b\x17\n\
    \x0c\n\x05\x04\t\x02\x01\x01\x12\x033\x18\x1f\n\x0c\n\x05\x04\t\x02\x01\
    \x03\x12\x033\"#\n\n\n\x02\x04\n\x12\x046\09\x01\n\n\n\x03\x04\n\x01\x12\
    \x036\x08\x14\n\x0b\n\x04\x04\n\x02\0\x12\x037\x02\x11\n\x0c\n\x05\x04\n\
    \x02\0\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\n\x02\0\x01\x12\x037\t\x0c\n\
    \x0c\n\x05\x04\n\x02\0\x03\x12\x037\x0f\x10\n\x0b\n\x04\x04\n\x02\x01\
    \x12\x038\x02\x13\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x038\x02\x08\n\x0c\n\
    \x05\x04\n\x02\x01\x01\x12\x038\t\x0e\n\x0c\n\x05\x04\n\x02\x01\x03\x12\
    \x038\x11\x12\n\n\n\x02\x04\x0b\x12\x04;\0>\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03;\x08\x10\n\x0b\n\x04\x04\x0b\x02\0\x12\x03<\x02\x11\n\x0c\n\x05\
    \x04\x0b\x02\0\x05\x12\x03<\x02\x07\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\
    \x03<\x08\x0c\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03<\x0f\x10\n\x0b\n\x04\
    \x04\x0b\x02\x01\x12\x03=\x02\x16\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\
    \x03=\x02\x08\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03=\t\x11\n\x0c\n\x05\
    \x04\x0b\x02\x01\x03\x12\x03=\x14\x15\n\n\n\x02\x04\x0c\x12\x04@\0B\x01\
    \n\n\n\x03\x04\x0c\x01\x12\x03@\x08\x11\n\x0b\n\x04\x04\x0c\x02\0\x12\
    \x03A\x02\x11\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03A\x02\x07\n\x0c\n\x05\
    \x04\x0c\x02\0\x01\x12\x03A\x08\x0c\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\
    \x03A\x0f\x10b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
